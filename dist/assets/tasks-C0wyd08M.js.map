{"version":3,"file":"tasks-C0wyd08M.js","sources":["../../src/contexts/TasksContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useAuth } from './AuthContext';\n\nconst TasksContext = createContext(null);\n\nexport function TasksProvider({ children }) {\n  const [tasks, setTasks] = useState([]);\n\n  const [isLoadingApi, setIsLoadingApi] = useState(false);\n  const { user, loading: authLoading } = useAuth();\n  const fetchTasksRef = useRef(null);\n  const hasFetchedInitialTasksRef = useRef(false); // Ref to ensure fetch is only triggered once per session\n\n  // Overall loading state: true if auth is loading OR (API is loading AND no tasks are yet displayed)\n  const loading = authLoading || (isLoadingApi && tasks.length === 0);\n\n  const fetchTasks = useCallback(async (currentUserId) => {\n    if (!currentUserId) {\n      setTasks([]);\n      setIsLoadingApi(false); // No user, so not loading from API\n      return;\n    }\n\n    setIsLoadingApi(true); // Start API loading\n\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) {\n        setTasks([]);\n        setIsLoadingApi(false);\n        return;\n      }\n\n      const response = await fetch('/api/tasks', {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      \n      if (response.ok) {\n        const data = await response.json();\n        setTasks(data);\n      } else {\n        setTasks([]);\n      }\n    } catch (error) {\n      console.error('Error fetching tasks:', error);\n      setTasks([]);\n    } finally {\n      setIsLoadingApi(false); // API fetch completed\n    }\n  }, []);\n\n  // Store the latest fetchTasks function in a ref\n  useEffect(() => {\n    fetchTasksRef.current = fetchTasks;\n  }, [fetchTasks]);\n\n  const updateTasks = useCallback((updatedTaskData) => {\n    setTasks(updatedTaskData);\n  }, []);\n\n  useEffect(() => {\n    if (!authLoading) { // Once auth loading is complete\n      if (user) {\n        // Trigger initial fetch of tasks only if not already fetched for this session\n        if (!hasFetchedInitialTasksRef.current) {\n          // Call fetchTasks and ensure hasFetchedInitialTasksRef is set after it completes\n          fetchTasksRef.current?.(user._id).finally(() => {\n            hasFetchedInitialTasksRef.current = true;\n          });\n        }\n      } else {\n        // If no user (e.g., logged out or failed auth), clear tasks and reset fetch flag\n        setTasks([]);\n        setIsLoadingApi(false);\n        hasFetchedInitialTasksRef.current = false; // Reset for next login\n      }\n    }\n  }, [authLoading, user]); // Re-run when auth status or user changes\n\n  const addTask = useCallback(async (title) => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) return;\n\n      const response = await fetch('/api/tasks', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify({ title })\n      });\n\n      if (response.ok) {\n        const newTask = await response.json();\n        setTasks(prevTasks => [...prevTasks, newTask]);\n        return newTask;\n      }\n    } catch (error) {\n      console.error('Error adding task:', error);\n    }\n  }, []);\n\n  const incrementPomodorosForTask = useCallback(async (taskId, duration) => {\n    if (!taskId) return;\n    try {\n      const response = await fetch(`/api/tasks/${taskId}/pomodoro`, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${localStorage.getItem('token')}`\n        },\n        body: JSON.stringify({ duration })\n      });\n\n      if (response.ok) {\n        const updatedTask = await response.json();\n        setTasks(prevTasks =>\n          prevTasks.map(task =>\n            task._id === updatedTask._id ? updatedTask : task\n          )\n        );\n      }\n    } catch (error) {\n      console.error('Error updating task:', error);\n    }\n  }, []);\n\n  const toggleTask = useCallback(async (taskId) => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) return;\n\n      const response = await fetch(`/api/tasks/${taskId}/toggle`, {\n        method: 'PATCH',\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      if (response.ok) {\n        setTasks(prevTasks =>\n          prevTasks.map(task =>\n            task._id === taskId ? { ...task, completed: !task.completed } : task\n          )\n        );\n      }\n    } catch (error) {\n      console.error('Error toggling task:', error);\n    }\n  }, []);\n\n  const deleteTask = useCallback(async (taskId) => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) return;\n\n      const response = await fetch(`/api/tasks/${taskId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      if (response.ok) {\n        setTasks(prevTasks => prevTasks.filter(task => task._id !== taskId));\n      }\n    } catch (error) {\n      console.error('Error deleting task:', error);\n    }\n  }, []);\n\n  const value = useMemo(() => ({\n    tasks,\n    loading,\n    fetchTasks,\n    addTask,\n    toggleTask,\n    deleteTask,\n    updateTasks,\n    incrementPomodorosForTask\n  }), [tasks, loading, fetchTasks, addTask, toggleTask, deleteTask, updateTasks, incrementPomodorosForTask]);\n\n  return (\n    <TasksContext.Provider value={value}>\n      {children}\n    </TasksContext.Provider>\n  );\n}\n\nexport function useTasks() {\n  const context = useContext(TasksContext);\n  if (!context) {\n    throw new Error('useTasks must be used within a TasksProvider');\n  }\n  return context;\n}\n"],"names":["TasksContext","createContext","TasksProvider","children","tasks","setTasks","useState","isLoadingApi","setIsLoadingApi","user","loading","authLoading","useAuth","fetchTasksRef","useRef","hasFetchedInitialTasksRef","length","fetchTasks","useCallback","currentUserId","token","localStorage","getItem","response","fetch","headers","ok","data","json","error","useEffect","current","updateTasks","updatedTaskData","_id","finally","addTask","title","method","body","JSON","stringify","newTask","prevTasks","incrementPomodorosForTask","taskId","duration","updatedTask","map","task","toggleTask","completed","deleteTask","filter","value","useMemo","_jsx","Provider","useTasks","context","useContext","Error"],"mappings":"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"}